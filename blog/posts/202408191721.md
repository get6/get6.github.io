---
title: Flutter에서 Feature-First 아키텍처 예제
date: 2024-08-19 17:21
tags:
  - flutter
  - architecture
---

![black and green hamming bird](https://images.unsplash.com/photo-1495819903255-00fdfa38a8de?q=80&w=2527&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)

## Feature-First 아키텍처
이전에도 관련된 글([Flutter에 Riverpod용 아키텍처 끼얹기](./202406011520))을 작성했지만, 예제에 대해서 만들어보진 않았어요.

Feature-First 아키텍처를 어떤 순서로 만들고 Riverpod을 통해 어떻게 만드는지 이번에 정리하고 저도 기억이 안날때마다 다시 보기 위해 작성해보려고 해요. 🥲

**Feature-First 아키텍처**는 소프트웨어 시스템을 설계하고 개발할 때 **Feature를 중심**으로 생각하는 접근 방식이에요. 즉, 사용자에게 제공할 기능을 먼저 정의하고, 이를 구현하기 위한 기술적인 부분을 나중에 고려하는 방식이죠.

> domain/entities, domain/use_cases, data/providers, data/models 폴더를 만드는 방식도 있는데 저는 안드리아가 제시한 방식으로 만들어 보려고 해요!

개발 아키텍처는 한가지 방식이 정답이 아니에요. 팀마다 다르고 사람마다 좋아하는게 다를거예요. 저도 이 아키텍처를 사용하려고 하지만 사용하면서 바뀌거나 다른 방식을 적용하게될 수도 있어요.
### 용어 정리
아키텍처를 기반으로 만들기 전에 알아야 할 것들은 먼저 정리하고 예제를 만들거예요.
우선 Feature에 대한 이해를 하고 갈게요.
- **Feature:** 사용자에게 제공되는 특정 기능이나 서비스를 의미해요. 예를 들어, 온라인 쇼핑몰의 '장바구니에 담기' 기능, 소셜 미디어의 '댓글 작성' 기능 등이 있어요. Feature는 사용자 관점에서 바라본 시스템의 기능을 나타내요.
- **Domain:** 시스템이 다루는 특정 영역 또는 문제 공간을 의미해요. 예를 들어, 온라인 쇼핑몰의 Domain은 '상품', '주문', '결제' 등이 될 수 있어요. Domain은 시스템의 내부적인 논리와 규칙을 담당해요.
**간단히 말해서,** Feature는 사용자가 직접적으로 보는 기능이고, Domain은 그 기능을 구현하기 위한 내부적인 모델과 규칙이에요.

폴더 구조내에서 feature 하나를 기반으로 폴더가 만들어지고 관련된 폴더과 파일을 만들어요.

그런데 이 아키텍처에는 features/feature1/domain 폴더가 있어요. 이때 domain 폴더는 위 domain의 정의와 동일하면서 Models이나 Entities의 역할을 해요.
### 개발 시작 전 정해야 할 것
항상 어떤 기능을 만들 때는 기획 단계에서 **이 서비스에는 어떤 기능이 있다가 정해지고 개발이 시작**되어야 해요. 이 기능이 어떤 역할을 하고 요구사항이 정의되어야 해요.

그러면 개발자는 유스케이스와 사용자 플로우를 파악해서 어떤 data가 필요하고 어떻게 DB에 저장될지 결정하면 돼요. 그런데 Flutter에서는 일반적으로 DB를 저장하는 역할을 맡고 있진 않으니, 유효성 검사를 마친 data를 DB에 저장할 수 있도록 전달할 수 있는 형태와 데이터를 APIs를 통해 가져왔을 때 필요한 data를 받는 객체를domain으로 생각해도 좋아요.

유스케이스(use case)와 사용자 플로우(user flow)를 조금 더 살펴볼게요. 사실 이 두가지는 개발자가 정의해야하는 건 아니긴 해요. 개발자는 이 요구사항을 코드로 구체화 시키면 돼요.
#### Use case(사용 사례)
- 사용자가 서비스(=시스템)를 이용해서 달성하고자 하는 목표를 작업할 수 있도록 수행하기 위한 일련의 정의된 동작이에요.

![Use case diagram - Wikipedia](https://upload.wikimedia.org/wikipedia/commons/1/1d/Use_case_restaurant_model.svg)
##### Use case 정의
- **주체:** 누가 이 기능을 사용하는가? (사용자, 관리자 등)
- **목표:** 사용자가 이 기능을 통해 무엇을 달성하고자 하는가?
- **전제 조건:** 기능을 사용하기 위한 사전 조건은 무엇인가?
- **수행 단계:** 기능을 수행하기 위한 단계는 무엇인가?
- **결과:** 기능 수행 후 어떤 결과가 나오는가?
- **예외:** 예상되는 예외 상황은 무엇인가?
#### User flow(사용자 흐름)
- 사용자가 특정 목표를 달성하기 위해 시스템과 상호작용하는 과정을 단계별로 시각화한 것
- 즉, 사용자가 어떤 순서로 어떤 화면을 거쳐 목표를 달성하는지를 보여줘요

![](assets/202408191721-20240819213907437.webp)
##### user flow 정의
- **시작점:** 사용자가 어디에서 시작하는가?
- **단계:** 사용자가 어떤 단계를 거쳐 목표를 달성하는가? 각 단계에서 사용자의 행동과 시스템의 반응을 명시합니다.
- **결과:** 사용자가 최종적으로 어떤 결과를 얻는가?
- **다른 경로:** 사용자가 다른 선택을 할 경우 어떤 경로를 거치는가?
#### 사용 예시
**use case:** 온라인 쇼핑몰에서 상품 구매하기
- **주체:** 일반 사용자
- **목표:** 원하는 상품을 구매하고 결제하기
- **전제 조건:** 회원 가입, 상품 검색
- **수행 단계:** 상품 상세 페이지 보기, 장바구니에 담기, 결제 정보 입력, 주문 완료
- **결과:** 주문 완료 메시지, 주문 내역 확인 가능
- **예외:** 재고 부족, 결제 실패
**user flow:**
1. 사용자가 상품 검색창에 키워드를 입력하고 검색 버튼을 클릭
2. 검색 결과 페이지에서 원하는 상품을 선택하고 상세 페이지로 이동
3. 상품 상세 페이지에서 상품 정보를 확인하고 장바구니에 담음
4. 장바구니 페이지에서 구매할 상품을 확인하고 결제 버튼을 클릭
5. 결제 정보를 입력하고 결제를 완료
6. 주문 완료 메시지가 표시되고, 주문 내역 페이지로 이동

이런 식으로 어떤 기능에 대해서 완벽하진 않더라도 정의를 하고 디자인 이후 개발하면 돼요. 그런데 Feature-First 아키텍처에서도 domain 영역에 entities와 usecases 폴더를 각각 만드는 방식도 있어요.

그때의 usecase는 비즈니스 로직을 담당해요. 상품 주문, 회원 가입 같은 사용자 작업에 대한 규칙과 알고리즘을 구현해요. 규칙과 알고리즘을 구현한다는 뜻은 사용자 로그인을 처리하거나 특정 게시물을 가져오는 등의 기능을 구현한다고 생각하면돼요. 이는 service 영역에서 하는 것과 비슷한 일이에요.
## 기능 하나를 개발할 순서
이제 드디어 쓰고 싶었던 부분이에요. 저는 약속 시간을 정하기 위해서 다들 자기가 되는 시간을 투표할 수 있도록 한명의 사용자가 약속을 위해 정한 여러 메타데이터(제목, 날짜, 시간대)를 가지는 데이터를 생성하는 기능을 만드려고 해요. 그렇다고 하나의 기능으로 볼 수 있지만 앱에서 보면 하나의 기능이 아니에요. 사용자 흐름에선 약속 시간 생성을 누르면 화면을 이동해서 제목을 입력받고 날짜들을 선택한 뒤, 시간대를 선택하고 생성을 누르면 약속 시간을 투표를 위한 준비까지가 하나의 기능으로 보는거예요.

> Feature-First 아키텍처에서 기능은 사용자가 서비스를 이용해 달성하고자 하는 완결된 목표를 의미해요.
> 개발자가 일반적으로 생각하는 기능(이벤트, 함수)과는 달라요.

어떤 feature를 개발하기 위해선 어떻게 시작해야할까요? 프론트엔드 입장에서 무얼 먼저 만드는 것이 좋은지 항상 고민이었어요. 사실 프론트엔드 입장에서 화면이 나와있다면 화면을 먼저 만들어보는 것도 좋은데 과연 이게 좋은 방법일까 하는 의문이 있었어요.

사실 이 부분에 대해서는 정답은 없어요. 그렇지만 우아한 형제들의 전 CTO이셨던 [김영한님의 답변](https://www.inflearn.com/community/questions/39853/%EC%84%A4%EA%B3%84-%EC%88%9C%EC%84%9C%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%A9%EB%8B%88%EB%8B%A4)도 고민의 답이 되는데 도움이 될 것 같아요.

>이 부분은 사실 정확한 정답은 없습니다.
>어떤 경우에는 화면부터 짜고 들어가는게 더 좋고, 어떤 경우에는 백단의 로직을 먼저 작성하는게 더 좋은 경우도 있습니다. 특히 웹 프론트엔드 개발자와 서버 개발자가 완전히 분리되어 있는 경우를 생각해보면 각각 동시에 업무를 진행하고, 붙여야 합니다. 이런 경우를 생각해보면 화면과 백단의 로직이 동시에 개발 진행될 수 있어야 합니다.
>그래서 중요한 것이 사실 요구사항 분석과 설계입니다. 재대로 요구사항을 분석하고, 설계해두고, 각 기능별로 어떻게 동작해야 하고, 어떤 데이터가 흐르는지 스펙을 명확하게 해두면 어느쪽으로든 진행할 수 있습니다.
>저는 핵심 비즈니스 기능은 백단부터 작업하는 것을 선호합니다.
>감사합니다^^

저도 비즈니스 기능부터 만들어 보려고 해요. 그리고 UI부터 만들게 되면 이러한 시나리오가 예상돼요.
1. UI 화면을 다 만들고 버튼 이벤트나 데이터 목록을 가져오고 화면을 표시해야 할 경우가 생김 <- 나중에 API나 상태 관리 추가하고 다시 확인해야 함
2. UI 화면을 다 만든 뒤, 순서를 controller나 service를 만들게 되면 결국 repository나 model을 주입하거나 참조해야 하는 경우가 생겨서 controller를 테스트하기 위해선 나머지가 선행되어야 함

이건 억지로 생각해본 사례이기 때문에 꼭 이런 문제가 생기는 건 아니지만, UI가 어떤 객체를 의존할 때, 그게 해결되기 전까지 개발하는 과정에서 오류가 떠있는 상태가 오래 지속될 수 있을 것 같아요. 또한 다른 계층을 만들 때 UI를 고려하게 된다면 UI쪽 코드를 변경하기 싫어서 의존성을 강하게 만들 수 있지 않을까 싶어요.

저는 기능 요구사항이 있으니 domain부터 만들게요. 이번에 만들 사례로 친구들과 약속 시간을 정하기 위한 시간을 투표하는 기능을 예로 들거예요.

대부분의 Riverpod을 사용하지만 controller 영역을 제외하고는 대부분 화면에서 직접 생성을 피하고 알아서 주입될 수 있는 싱글톤으로 사용할 거예요.

### Domain 계층 구현
Entities에 해당하는 주요 엔티티(=모델)를 정의해요. 저는 시간 투표를 위한거니깐 voting이라는 기능의 이름을 생각했다가 일정과 관련된 서비스라고 생각해서 lib/src/features/calendar 폴더를 만들었어요. 기능을 잘못만들거나 잘못된 위치에 기능을 만들어도 나중에 파일명만 바꾸면 되니깐 일단은 크게 신경쓰지 않도록 했어요. 엔티티 이름은 [When2meet](https://www.when2meet.com/)이라는 서비스가 있어서 features/calendar/domain/when_to_meet.dart 파일을 만들거예요.

> 코드를 보면 저는 code generator를 사용하고 있어서 part 부분이 추가되어 있어요.
> `flutter pub run build_runner watch`를 입력하고 개발해주세요.
> 저는 편하게 쓰기 위해서 VS Code에서 Build Runner 확장을 사용하고 있어요.

```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:my_awesome_ittae/src/features/calendar/domain/time_slot.dart';
import 'package:my_awesome_ittae/src/features/users/data/user.dart';

part 'when_to_meet.freezed.dart';
part 'when_to_meet.g.dart';

typedef WhenToMeetID = String;

/// WhenToMeet은 약속 시간을 정하기 위해 사용되는 클래스입니다.
@freezed
class WhenToMeet with _$WhenToMeet {
  const factory WhenToMeet({
    WhenToMeetID? id,
    required String title,
    required String? location,
    required UserID creator,
    required List<User> invitees,
    required List<User> attendees,
    required Map<DateTime, Set<TimeSlot>> availableTimes,
    required Map<UserID, Map<DateTime, TimeSlot>> selectedTimes,
  }) = _WhenToMeet;

  factory WhenToMeet.fromJson(Map<String, dynamic> json) =>
      _WhenToMeet.fromJson(json);
}
```

### Data 계층 구현
데이터 계층에서는 로컬 or 원격으로부터 데이터 CRUD를 처리해요. 특정 Entity마다 CRUD 중 구현해야 하는 것이 다를 수 있지만 이번에는 CRUD 모두를 추상화할거예요. 이 부분 역시 VS Code 스니펫을 이용한다면 편리할거예요.

```dart
import 'package:my_awesome_ittae/src/features/calendar/domain/when_to_meet.dart';

// features/calendar/data/when_to_meet_repository.dart 파일로 생성하기
abstract class WhenToMeetRepository {
  Future<List<WhenToMeet>> getWhenToMeets();
  Future<void> addWhenToMeet(WhenToMeet whenToMeet);
  Future<void> deleteWhenToMeet(WhenToMeet whenToMeet);
  Future<void> updateWhenToMeet(WhenToMeet whenToMeet);
}
```

이제 구현체를 만들어줄거예요. 저는 firestore를 이용하고 있기 때문에 아래와 비슷한 이름으로 만들어주면 돼요.
- remote_when_to_meet_repository.dart
- firesbase_when_to_meet_repository.dart

Repository 내부에 FirebaseFiresotre를 통해 데이터를 외부에서 조작해요. 그래서 이걸 외부에서 주입해줄거예요. RemoteWhenToMeetRepository을 사용하는 쪽에서 직접 생성하지 않고 provider를 통해 넘겨받을거예요. 이런식으로 Riverpod을 통해 필요한 계층을 담당하는 객체를 넘겨받고 넘겨줄거예요.

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:my_awesome_ittae/src/features/calendar/data/when_to_meet_repository.dart';
import 'package:my_awesome_ittae/src/features/calendar/domain/when_to_meet.dart';

part 'remote_when_to_meet_repository.g.dart';

class RemoteWhenToMeetRepository implements WhenToMeetRepository {
  const RemoteWhenToMeetRepository(this._fs);
  final FirebaseFirestore _fs;

  CollectionReference get _whenToMeetCollection => _fs.collection('when_to_meet');

  @override
  Future<void> addWhenToMeet(WhenToMeet whenToMeet) {
    return _whenToMeetCollection.doc(whenToMeet.id).set(whenToMeet.toJson());
  }

  @override
  Future<void> deleteWhenToMeet(WhenToMeet whenToMeet) {
    return _whenToMeetCollection.doc(whenToMeet.id).delete();
  }

  @override
  Future<List<WhenToMeet>> getWhenToMeets() {
    return _whenToMeetCollection.get().then((snapshot) {
      return snapshot.docs.map((doc) {
        return WhenToMeet.fromJson(doc.data() as Map<String, dynamic>);
      }).toList();
    });
  }

  @override
  Future<void> updateWhenToMeet(WhenToMeet whenToMeet) {
    return _whenToMeetCollection.doc(whenToMeet.id).update(whenToMeet.toJson());
  }
}

@riverpod
WhenToMeetRepository whenToMeetRepository(WhenToMeetRepositoryRef ref) {
  return RemoteWhenToMeetRepository(fs: ref.read(firebaseFirestoreProvider));
}
```

테스트를 위해선 FakeWhenToMeetRepository를 만들고 각 함수에서 임의의 값을 설정해서 반환하면 테스트하기 편할거예요.

firebaseFirestoreProvider는 lib/src/common/providers/general_providers.dart 파일에 만들어줬어요.

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'general_provider.g.dart';

@riverpod
FirebaseFirestore firebaseFirestore(FirebaseFirestoreRef ref) {
  return FirebaseFirestore.instance;
}
```

### Application 구현
이제 WhenToMeetService를 만들 차례가 왔어요. 이 서비스는 비즈니스 로직을 처리해요.

```dart
import 'package:my_awesome_ittae/src/features/calendar/data/remote_when_to_meet_repository.dart';
import 'package:my_awesome_ittae/src/features/calendar/domain/when_to_meet.dart';
import 'package:my_awesome_ittae/src/features/users/data/user.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'when_to_meet_service.g.dart';

class WhenToMeetService {
  WhenToMeetService({
    required this.remoteWhenToMeetRepository,
  });
  final RemoteWhenToMeetRepository remoteWhenToMeetRepository;

  Future<void> addWhenToMeet(WhenToMeet whenToMeet) {
    return remoteWhenToMeetRepository.addWhenToMeet(whenToMeet);
  }

  Future<WhenToMeet> fetchWhenToMeet(WhenToMeetID id) {
    return remoteWhenToMeetRepository.getWhenToMeet(id);
  }

  Future<void> updateWhenToMeet(WhenToMeet whenToMeet) {
    return remoteWhenToMeetRepository.updateWhenToMeet(whenToMeet);
  }
}

@riverpod
WhenToMeetService whenToMeetService(WhenToMeetServiceRef ref) {
  return WhenToMeetService(
    remoteWhenToMeetRepository: ref.read(remoteWhenToMeetRepositoryProvider),
  );
}
```

서비스에는 데이터를 추가하고 갱신하고, 단건을 받아와요. 함수 이름을 repository와 비슷하게 만들고 싶은 욕구도 들지만, 최대한 의미를 담아도 좋을 것 같아요. 원래라면 더 많은 함수들이 있어야 할거예요. 로그인했던 사용자가 생성하거나 참여했던 목록을 가져와야 할 수도 있지만, 지금은 단순하게 만들게요. 지금은 따로 처리를 하진 않았지만, 필요하다면 service 함수내에서 어떤 처리를 할 수도 있을거예요.
### Presentation 구현
이제 Screen과 Controller를 만들거예요. 저는 Screen과 Controller는 플랫폼마다 다르게 만들어야 할 것 같다고 생각해요. 모바일, 태블릿, 데스크탑 스크린에 따라 표현해야 할 UI가 달라질텐데, UI가 달라지면 처리하는 데이터는 같더라도 한번에 처리되거나 화면 전환이 되면서 데이터를 하나씩 모으는 경우라면 Screen의 갯수와 그 Screen에서 상태 관리를 해야하는 경우 Controller도 달라질거라고 생각해요.

이번에는 모바일용 화면만 만들어볼게요. 제목 입력, 날짜 선택, 시간대 선택을 위해 최소 3개의 화면이 필요하지만, 글이 굉장히 길어질 것 같아서 가장 첫번째 화면인 제목 입력 부분만 파일로 만들게요. 먼저 controller를 만들게요. 입력받을 제목을 저장하기 위한 함수만 필요해요. 입력 상태는 page에서 관리할게요.

controller에 작성될 함수는 주로 유효성 검증이 끝난 입력 데이터를 받거나, 위젯이 렌더링 되는 시점에 데이터를 전달하거나, 버튼 같은 이벤트를 통해 데이터를 전달하는 경우가 대부분이에요.

```dart
```

---

> [!quote] You can stand tall without standing on someone. You can be a victor without having victims.
> — Harriet Woods