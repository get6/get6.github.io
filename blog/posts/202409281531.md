---
title: 리눅스 디렉토리별 설명
date: 2024-09-28 15:31
tags:
  - linux
  - folder structure
---

![photo by Ben Grayland on Unsplash](https://images.unsplash.com/photo-1725345652396-5679f405a10a?crop=entropy&cs=srgb&fm=jpg&ixid=M3w2NDU1OTF8MHwxfHJhbmRvbXx8fHx8fHx8fDE3Mjc1MDUxMDZ8&ixlib=rb-4.0.3&q=85&w=768&h=432)

**모두를 위한 리눅스 프로그래밍** 책에서 소개된 FHS 구조로 이루어진 리눅스 시스템에서 각 폴더별로 어떤 역할을 하는지 정리했어요.
## 디렉터리 구조
리눅스 디렉터리 트리의 표준 규격인 File system Hierarchy Standard(FHS)를 사용해요.

**/**
트리의 뿌리이자, 루트 디렉터리. 이게 없다면 리눅스는 부팅조차 할 수 없어요.

**/bin**
user command binaries
실행 파일(명령어)이 보관되는 장소예요. 부팅할 때 필요한 시스템의 기본 명령어가 있고, `/usr/bin`에는 그 외의 일반 사용자를 위한 명령어가 있어요. 요즘 OS버전은 이 둘을 구별하지 않기도 해요. `/bin`과 `/usr/bin`은 배포판이 관리하는 디렉터리이므로 패키지 시스템을 사용하지 않아요. 직접 설치하는 명령어는 `/usr/local/bin` 등에 보관하는 것이 바람직해요.

**/sbin**
system binaries
관리자용 명령어들이 위치해요. 부팅할 때 필요한 관리자용 명령어들도 있어요. `/urs/sbin`에는 평상시 사용하는 시스템 관리 명령어나 서버 프로그램이 배치돼요.

**/lib**
`/lib`, `/lib64`에는 C, 파이썬, 루비 등의 라이브러리가 있어요.

**/usr**
여러 컴퓨터에서 공유할 수 있는 파일을 보관하는 용도예요. 이 밑으로 필수적인 파일들이 들어있어요. usr의 어원은 User Services and Routines이지만 요즘은 그냥 user로 봐요. 공유할 수 없는 파일들은 `/var`에 보관돼요.

**/usr/src**
시스템에서 사용되는 명령어의 소스 코드나 리눅스 커널의 소스 코드가 보관되어 있어요. 직접 작성한 프로그램의 소스 코드는 여기에 보관하지 않도록 해야 해요.

**/usr/include**
시스템의 헤더 파일들이 있어요. 커널의 헤더 파일은 `/usr/include/linux`에 보관돼요. 유닉스 계열의 운영체제에서는 `/usr/include/sys` 밑에 커널의 헤더 파일이 보관되지만, 리눅스는 커널과 libc의 관리자가 다르기 때문에 약간 다른 구조를 띠어요.

**/usr/share**
아키텍처(CPU 종류)에 의존하지 않아서 서로 다른 아키텍처에서도 공유할 수 있는 파일들이 있어요. man 명령어나 info의 데이터가 이 밑에 있어요.

**/usr/share/man**
배포판에 따라 `/usr/man`에 보관하기도 하지만, FHS에서는 `/usr/share/man`에 보관돼요. man1, man2, man3...로 되어 있고 뒤에 붙어 있는 번호가 섹션 번호예요. 섹션 1의 경우 `/usr/share/man/man1`에 있어요. 폴더마다 페이지가 나열되어 있고 파일 이름은 '도큐먼트 이름.섹션' 형식으로 되어있어요.

**/usr/local**
`/usr`와 비슷하게 bin, sbin, lib, share 등의 디렉터리가 있어요. 다른 점은 파일의 관리 주체예요. `/usr`은 배포판이 관리하고 `/usr/local`은 각 시스템의 관리자(사용자)에게 관리 책임이 있어요.

**/var**
variable data files가 모여 있는 곳이에요. 자주 바뀌는 파일을 저장하기 위해 사용해요. 여러 컴퓨터에서 공유하는 파일을 저장하기에는 적합하지 않아요. 리눅스를 서버로 쓰는 경우 로그나 메일 박스가 위치하기 때문에 매우 중요해요.

**/var/log**
서버 프로세스가 쓰는 로그 파일이 저장돼요. 로그 파일이란 프로그램에서 발생하는 이벤트가 기록되는 파일을 말해요.

**/var/spool**
사용자 메일(/var/spool/mail)이나 프린트 입력(`/var/spool/cups`)이 일시적으로 저장돼요.
**SPOOL**(Simultaneous Peripheral Operation On-Line)은 컴퓨터 시스템에서 중앙처리장치와 입출력장치가 독립적으로 동작하도록 함으로써 중앙처리장치에 비해 주변장치의 처리속도가 느려서 발생하는 대기시간을 줄이기 위해 고안된 기법이에요.

**/var/run**
실행 중인 서버 프로세스의 프로세스 ID가 저장돼요. 이러한 파일을 PID 파일이라고 해요. 서버를 만들 때는 기동 시에 이 폴더에다 프로세스 ID를 기록하고, 종료할 때는 제거해 주는 것이 일종의 매너예요. 해당 폴더에서 .pid로 끝나는 파일의 내용을 보면 PID를 확인할 수 있어요.

**/etc**
etcetera로 각 시스템의 설정 파일이 보관돼요.

**/dev**
devices로 모든 종류의 디바이스 파일을 여기에 두는 것이 유닉스의 전통적인 방식이었어요. 리눅스 2.4 이후부터는 시스템에 존재하는 디바이스 파일만을 그때마다 작성하는 Device File System(devfs)가 도입되었어요. 리눅스 2.6부터는 udev라는 구조가 도입되었어요.

새로운 구조가 도입된 이유는 커널이 지원하는 하드웨어가 너무 많아졌기 때문이에요. devfs는 커널의 일부로 구현되어 있지만, udev는 커널 밖에 구현되어 있어요.

**/proc**
process로 여기에는 일반적으로 프로세스 파일 시스템 Process File System(procfs)이 탑재돼요. 프로세스 파일 시스템은 말 그대로 프로세스를 파일 시스템으로 표현한 거예요. PID가 1인 프로세스의 정보를 얻고 싶다면 폴더 /proc/1을 보면 돼요. 그러나 요즘은 ps 명령어를 통해 확인하는 편이에요.

**/sys**
procfs에 프로세스와 관계없는 정보들이 탑재되기 시작하면서 시스템 관련 정보를 별도로 제공하기 위해 리눅스 2.6부터 sysfs라는 새로운 파일 시스템이 추가되었어요. sysfs를 탑재하는 폴더가 여기예요. 시스템에 존재하는 장치나 장치 드라이버의 정보를 얻을 수 있어요.

**/boot**
리눅스 커널은 vmlinuz라는 파일에 담겨 있어요. BSD에서 가상 메모리 메커니즘을 포함할 때 unix에서 vmunix로 바뀌었어요. 이를 압축하면서 끝이 z가 되어 vmlinuz가 되었어요. 커널 프로그램은 원래 루트 폴더에 직접 보관했는데 최근에는 여기로 보관하게 되었어요.

**/root**
슈퍼 사용자의 홈 폴더가 /root예요. 예전에는 루트 폴더가 슈퍼 사용자의 홈 폴더였어요.

**/tmp, /var/tmp**
임시로 어딘가에 파일을 만들고 싶은 경우가 있어요. 그럴 때 해당 폴더를 이용하면 돼요. 두 폴더는 저장 기간이 달라요. `/tmp`는 재부팅하면 삭제될 수 있으나, `/var/tmp`는 재부팅해도 삭제되지 않아요. 한 예로 vi의 복구 파일이 `/var/tmp`에 저장돼요.

**/home**
일반 사용자의 홈 폴더는 환경변수로 $HOME으로 접근이 가능해요. 큰 조직에서는 /home1, /home2처럼 뒤에 숫자를 붙이기도 해요.

홈 폴더 경로가 다를 수 있는 상황이 있으므로 전용 API를 사용하는 것이 안전해요.
## 폴더 구분 기준
| 관점                              | O        | X          |
| --------------------------------- | -------- | ---------- |
| 복수의 호스트에서 공유하는지 여부 | /usr     | /var       |
| 읽기 전용으로 운영되는지 여부     | /usr     | /var       |
| 아키텍처에 의존적인지 여부        | /usr/lib | /usr/share |
| 배포자가 관리하는지 여부          | /usr     | /usr/local |
| 재부팅해도 남아 있는지 여부       | /var/tmp | /tmp           |

이외에도 중요한 관점으로 다음과 같은 것들이 있어요.
- 백업이 필요한지 여부(변하는지, 복구가 필요한지 여부)
- 사용자별로 필요한지, 시스템당 하나만 있으면 되는지 여부
- 권한을 나눠야 하는지 여부
- 셸에서 glob 패턴으로 지정할 수 있으면 편리한지 여부
## 명령어 정리
builtin(빌트인)은 Shell의 내장 명령어예요.
### man
bash나 zsh 같은 터미널에서 `man man` 을 치면 자세한 설명을 볼 수 있어요.

man은 찾고자 하는 명령어에 대한 설명을 보여줘요. 42서울에서 시험을 치거나 과제를 할 때 `man 찾고자 하는 명령어` 를 입력해 정보를 찾을 수 있어요. man을 통해 함수를 보다 보면 마지막 줄 근처에 SEE ALSO라는 관련 함수를 보여줘요. 함수 옆에 괄호로 둘러싸인 번호가 있는데 이건 바로 **manual sections**이에요.

**Manual sections**
각 구현된 명령어가 아래 내용과 함께 보면 어떤 section과 연관되어 있는지 확인할 수 있어요.
1. User Commands = 일반 명령어
2. System Calls = 시스템 호출
3. C Library Functions = C 표준 라이브러리 함수들
4. Devices and Special Files = 특수 파일 (보통 /dev에서 발견되는 장치 파일)과 드라이버
5. File Formats and Conventions = 파일 형식과 협약
6. Games et. Al. = 게임과 화면 보호기
7. Miscellanea = 기타
8. System Administration tools and Deamons = 시스템 관리 명령어와 데몬

보통 많이 보게 되는 건 1번이고 42서울에서 과제를 하려면 3번도 많이 찾게 돼요. 요즘이야 구글로 검색해서 찾으면 한글화나 정리가 잘된 글들을 볼 수 있지만 이 명령어를 통해 설명을 보는 것도 가끔은 좋지 않을까 생각이 들어요.

**man 옵션**
옵션들 중 엄청 유용한 걸 발견하진 못했어요. 그래도 알게 된 몇 가지를 적어볼게요.

-w 옵션을 사용하면 ex) `man -w sed` 해당 명령어 설명서가 적힌 경로를 출력해요.
vim으로 `man sed` 와 비교해서 보면 어떻게 작성되고 해당 문서 형식을 살펴볼 수 있어요.

-k 옵션을 사용하면 ex) `man -k variables` 해당 키워드를 포함한 매뉴얼 목록을 보여줘요.
특정 키워드나 문구를 기억해야 효과가 있을 듯해요. 옵션에 명령어 같은 거 적으면 해당 명령어를 포함하는 단어 같은 게 나와서 별 효과가 없어요. ex) man -k sed -> used

보통 숫자를 안 넣고 man을 쓰면 첫 번째 영역의 정보를 보여주지만, 숫자를 넣고 명령어를 치면 ex) `man 1 sed` 해당 영역에 있는 명령어를 찾아줘요. 최대한 중복되는 명령어를 피해서 작성했겠지만, 불가피한 경우는 중복이 되어 옵션을 제공하는 것 같아요.

---

> [!quote] To become what you are not, behave as you do not.
> — T.S. Eliot